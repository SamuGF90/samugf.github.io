<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Publications | Gergely Samu</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body class="bg-gray-50 text-gray-800 font-sans">

  <!-- Navbar -->
  <header class="bg-white shadow sticky top-0 z-10">
    <div class="max-w-6xl mx-auto px-4 py-4 flex justify-between items-center">
      <h1 class="text-xl font-bold">Gergely Samu</h1>
      <nav class="space-x-4">
        <a href="index.html" class="hover:text-blue-600">Home</a>
        <a href="publications.html" class="text-blue-600 font-semibold">Publications</a>
        <a href="contact.html" class="hover:text-blue-600">Contact</a>
      </nav>
    </div>
  </header>

  <!-- Publications -->
  <section class="py-20">
    <div class="max-w-4xl mx-auto px-4">
      <h3 class="text-3xl font-bold mb-6">Publications</h3>

     <!-- Scientometric Summary Section -->
<div class="bg-white p-4 rounded shadow mb-6">
  <h2 class="text-lg font-semibold mb-4">Scientometric Summary</h2>

  <div class="flex flex-col md:flex-row items-start gap-6">

    <!-- Left: Stats + Badges -->
    <div class="md:w-1/2 w-full text-left text-[1rem] text-gray-800 flex flex-col justify-start mt-12 pl-20">

      <!-- Stats -->
      <div class="mb-4">
        <p class="mb-2"><span class="font-semibold">Total Citations:</span> 1898</p>
        <p class="mb-2"><span class="font-semibold">Citations since 2019:</span> 1554</p>
        <p class="mb-2"><span class="font-semibold">h-index:</span> 24</p>
        <p><span class="font-semibold">i10-index:</span> 42</p>
        <p class="mt-2 text-xs text-gray-500 italic">Last updated: August 2025</p>
      </div>

      <!-- Badges -->
      <div class="flex flex-wrap gap-4">
        <a href="https://orcid.org/0000-0002-3239-9154" target="_blank" title="ORCID">
          <img src="images/icons/ORCID.png" alt="ORCID" 
          class="h-10 w-10 transition-transform transform hover:scale-110 hover:shadow-md hover:bg-gray-100 p-1 rounded">
        </a>
        <a href="https://scholar.google.com/citations?user=aIPTi40AAAAJ&hl=hu" target="_blank" title="Google Scholar">
          <img src="images/icons/scholar.png" alt="Google Scholar" 
          class="h-10 w-10 transition-transform transform hover:scale-110 hover:shadow-md hover:bg-gray-100 p-1 rounded">
        </a>
        <a href="https://m2.mtmt.hu/gui2/?type=authors&mode=browse&sel=10040508&view=dataSheet" target="_blank" title="MTMT">
          <img src="images/icons/mtmt.png" alt="MTMT" 
          class="h-10 w-10 transition-transform transform hover:scale-110 hover:shadow-md hover:bg-gray-100 p-1 rounded">
        </a>
        <a href="https://www.researchgate.net/profile/Gergely-Samu?ev=hdr_xprf" target="_blank" title="ResearchGate">
          <img src="images/icons/ResearchGate.png" alt="ResearchGate" 
          class="h-10 w-10 transition-transform transform hover:scale-110 hover:shadow-md hover:bg-gray-100 p-1 rounded">
        </a>
        <a href="https://www.scopus.com/authid/detail.uri?authorId=55940039800" target="_blank" title="Scopus">
          <img src="images/icons/Scopus.png" alt="Scopus" 
          class="h-10 w-10 transition-transform transform hover:scale-110 hover:shadow-md hover:bg-gray-100 p-1 rounded">
        </a>
      </div>
    </div>

    <!-- Divider -->
    <div class="hidden md:block w-px bg-gray-300 h-auto self-stretch"></div>

    <!-- Right: Donut chart -->
<div class="md:w-1/2 w-full">
  <!-- Fixed-height wrapper so the chart can’t “fall” -->
  <div class="relative h-64 md:h-80">
    <canvas id="expertiseDonut" class="w-full h-full"></canvas>
  </div>

  <div id="expertiseLegend" class="mt-3 flex flex-wrap gap-3 text-sm"></div>
</div>
  </div>
</div>

      <!-- Filters -->
<div class="mb-4">
  <div class="flex flex-col sm:flex-row sm:items-end gap-4">
    <!-- Year -->
    <div>
      <label for="yearSelect" class="block mb-2 text-gray-700 font-medium">Filter by Year:</label>
      <select id="yearSelect" class="p-2 border border-gray-300 rounded-md">
        <option value="all">All Years</option>
      </select>
    </div>

    <!-- Keyword -->
    <div>
      <label for="keywordSelect" class="block mb-2 text-gray-700 font-medium">Filter by Keyword:</label>
      <select id="keywordSelect" class="p-2 border border-gray-300 rounded-md">
        <option value="all">All Keywords</option>
      </select>
    </div>
  </div>
</div>

      <!-- List -->
      <ul id="pubList" class="space-y-4 text-gray-700 text-lg">
      </ul>
    </div>
  </section>

 
  <!-- Script to fetch publications -->
<script>
const pubList = document.getElementById("pubList");
const yearSelect = document.getElementById("yearSelect");
const keywordSelect = document.getElementById("keywordSelect");

function formatAuthor(name) {
  const parts = name.split(",");
  if (parts.length === 2) {
    const last = parts[0].trim();
    const first = parts[1].trim();
    const full = `${first} ${last}`;
    return full === "G.F. Samu" ? `<strong>${full}</strong>` : full;
  }
  return name;
}

async function buildPublicationList() {
  try {
    const response = await fetch("orcid-details.json", { cache: "no-store" });
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    const publications = await response.json();
 
  // Sort by year descending
  publications.sort((a, b) => b.year.localeCompare(a.year));

  // Build the donut from keywords in JSON
  buildExpertiseDonutFromPublications(publications);

  const indexMap = new Map();
publications.forEach((p, i) => {
  const key = p.doi || p.title;  // Prefer DOI as unique key
  indexMap.set(key, i);
});
 
  // Populate year dropdown
  const years = [...new Set(publications.map(p => p.year))].sort((a, b) => b - a);
  years.forEach(y => {
    const option = document.createElement("option");
    option.value = y;
    option.textContent = y;
    yearSelect.appendChild(option);
  });

  // Build unique keyword list
const keywordSet = new Set();
publications.forEach(p => (p.keywords || []).forEach(k => {
  if (!k) return;
  keywordSet.add(k.trim().toLowerCase());
}));

[...keywordSet].sort().forEach(k => {
  const opt = document.createElement("option");
  opt.value = k;
  opt.textContent = titleCase(k);;
  keywordSelect.appendChild(opt);
});

  function render(filterYear = "all", filterKeyword = "all") {
  pubList.innerHTML = "";

  const filtered = publications.filter(p => {
    const yearMatch = filterYear === "all" || p.year === filterYear;
    const keywordMatch = filterKeyword === "all" || (p.keywords || []).includes(filterKeyword);
    return yearMatch && keywordMatch;
  });

  if (filtered.length === 0) {
    pubList.innerHTML = `<li class="text-gray-500">No publications for selected filters.</li>`;
    return;
  }

    filtered.forEach(p => {
        const key = p.doi || p.title;
  const globalIndex = indexMap.get(key);
  const highlightedAuthors = p.authors.map(formatAuthor).join(", ");
  const tocImgHTML = p.toc ? `<img src="${p.toc}" alt="TOC Figure" class="mt-2 rounded shadow max-w-xs">` : "";
  const abstractHTML = p.abstract ? `<p class="mt-2">${p.abstract}</p>` : "";

  const li = document.createElement("li");
  li.className = "bg-white p-4 rounded shadow";

  li.innerHTML = `
    <div class="font-semibold text-gray-900 mb-1">[${publications.length - globalIndex}] ${p.title}</div>
    <div class="text-sm text-gray-600 mb-1">${highlightedAuthors}</div>
    <div class="text-sm text-gray-600">${p.journal} • ${p.year}
      ${p.doi ? ` <a href="${p.doi}" target="_blank" class="text-blue-600 hover:underline ml-2">(DOI)</a>` : ""}
    </div>

    ${(p.abstract || p.toc) ? `
      <button class="text-blue-600 mt-2 text-sm hover:underline toggle-btn">Show more</button>
      <div class="collapse-content mt-2 hidden text-sm text-gray-700">
  <div class="flex flex-col md:flex-row gap-4">
    ${p.abstract ? `<div class="md:w-2/3 text-justify">${p.abstract}</div>` : ""}
    ${p.toc ? `<div class="md:w-1/3"><img src="${p.toc}" alt="TOC Figure" class="rounded shadow max-w-full h-auto"></div>` : ""}
  </div>
</div>
    ` : ""}
  `;

  const btn = li.querySelector(".toggle-btn");
  const content = li.querySelector(".collapse-content");
  if (btn && content) {
    btn.addEventListener("click", () => {
      content.classList.toggle("hidden");
      btn.textContent = content.classList.contains("hidden") ? "Show more" : "Show less";
    });
  }

  pubList.appendChild(li);
});
  }

  
  yearSelect.addEventListener("change", () => {
  render(yearSelect.value, keywordSelect.value);
});

keywordSelect.addEventListener("change", () => {
  render(yearSelect.value, keywordSelect.value);
});

// Initial render
render("all", "all");
  } catch (err) {
    console.error("Failed to load publications:", err);
    pubList.innerHTML = `<li class="text-gray-500">Couldn’t load publications. Please try again later.</li>`;
  }
}
buildPublicationList();
buildExpertiseDonutFromPublications(filtered);

</script>

<script>
  let expertiseChart = null; // keep a reference so we can update/recreate

function titleCase(label) {
  return label.replace(/\b\w/g, c => c.toUpperCase());
}

function computeKeywordCounts(publications, {minCountForOwnSlice = 2} = {}) {
  const counts = new Map();
  publications.forEach(p => {
    (p.keywords || []).forEach(k => {
      const key = k.trim().toLowerCase();
      if (!key) return;
      counts.set(key, (counts.get(key) || 0) + 1);
    });
  });

  // Split into major slices and "other"
  const majors = [];
  let otherTotal = 0;
  for (const [key, count] of counts.entries()) {
    if (count >= minCountForOwnSlice) majors.push({ label: titleCase(key), value: count });
    else otherTotal += count;
  }
  if (otherTotal > 0) majors.push({ label: "Other", value: otherTotal });

  // Sort desc by value
  majors.sort((a,b) => b.value - a.value);
  return majors;
}

function buildExpertiseDonutFromPublications(publications) {
  const EXPERTISE = computeKeywordCounts(publications, { minCountForOwnSlice: 2 });
  const canvas = document.getElementById("expertiseDonut");
  if (!canvas) return;
  const ctx = canvas.getContext("2d");

  // Center text plugin (same as before, safe to keep)
  const centerText = {
    id: "centerText",
    afterDraw(chart) {
      const { ctx, chartArea } = chart;
      if (!chartArea) return;
      const { left, right, top, bottom } = chartArea;
      const activeIdx = chart._active?.[0]?.index ?? null;
      const data = chart.data.datasets[0].data;
      const labels = chart.data.labels;
      const total = data.reduce((a,b)=>a+b,0);
      let text = "Areas of Expertise";
      if (activeIdx !== null) {
        const pct = Math.round((data[activeIdx] / total) * 100);
        text = `${labels[activeIdx]} • ${pct}%`;
      }
      ctx.save();
      ctx.font = "600 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillStyle = "#374151";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(text, (left + right) / 2, (top + bottom) / 2);
      ctx.restore();
    }
  };

  // Hover shadow plugin (from before)
  const sliceHover = {
    id: "sliceHover",
    afterDatasetsDraw(chart, args, opts) {
      const active = chart.getActiveElements?.() || [];
      if (!active.length) return;
      const { ctx } = chart;
      ctx.save();
      ctx.shadowColor = opts.shadowColor || "rgba(0,0,0,0.22)";
      ctx.shadowBlur = opts.shadowBlur || 14;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 4;
      active.forEach(({ datasetIndex, index }) => {
        const el = chart.getDatasetMeta(datasetIndex).data[index];
        el.draw(ctx);
      });
      ctx.restore();
    }
  };

  // Destroy previous chart if it exists
  if (expertiseChart) {
    expertiseChart.destroy();
  }

  expertiseChart = new Chart(ctx, {
    type: "doughnut",
    data: {
      labels: EXPERTISE.map(x => x.label),
      datasets: [{
        data: EXPERTISE.map(x => x.value),
        borderWidth: 0,
        hoverOffset: 10
        // optional: backgroundColor: ['#2563eb','#10b981', ...]
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,   // works with your fixed-height wrapper
      cutout: "60%",
      animations: { radius: { duration: 200, easing: "easeOutQuad" } },
      onHover(evt, active) {
        evt.native.target.style.cursor = active.length ? "pointer" : "default";
      },
      plugins: {
        legend: { display: false },
        tooltip: {
          callbacks: {
            label(ctx) {
              const data = ctx.dataset.data;
              const total = data.reduce((a,b)=>a+b,0);
              const v = data[ctx.dataIndex];
              const pct = Math.round((v/total)*100);
              return ` ${ctx.label}: ${v} (${pct}%)`;
            }
          }
        },
        sliceHover: { shadowBlur: 14, shadowColor: "rgba(0,0,0,0.22)" }
      },
      layout: { padding: 10 },

      onClick(evt, elements, chart) {
  if (!elements.length) return;
  const idx = elements[0].index;
  const label = chart.data.labels[idx];
  if (label === "Other") return;

  const kw = label.toLowerCase();
  const keywordSelect = document.getElementById("keywordSelect");
  if (!keywordSelect) return;

  // toggle off if same slice clicked again (optional)
  if (keywordSelect.value === kw) {
    keywordSelect.value = "all";
  } else {
    // ensure option exists (in case of grouping differences)
    let opt = [...keywordSelect.options].find(o => o.value === kw);
    if (!opt) {
      opt = document.createElement("option");
      opt.value = kw;
      opt.textContent = label;
      keywordSelect.appendChild(opt);
    }
    keywordSelect.value = kw;
  }

  // trigger re-render via existing listener
  keywordSelect.dispatchEvent(new Event("change"));
},
    },
    plugins: [centerText, sliceHover]
  });

  // Build legend pills
  const legendHost = document.getElementById("expertiseLegend");
  if (legendHost) {
    legendHost.innerHTML = "";
    const colors = expertiseChart.data.datasets[0].backgroundColor || [];
    EXPERTISE.forEach((item, i) => {
      const color = colors[i] || "#e5e7eb";
      const pill = document.createElement("span");
      pill.className = "inline-flex items-center gap-2 px-2 py-1 rounded-full border";
      pill.innerHTML = `<span style="display:inline-block;width:10px;height:10px;border-radius:9999px;background:${color}"></span>${item.label}`;
      legendHost.appendChild(pill);
    });
  }
}
</script>

</body>
</html>